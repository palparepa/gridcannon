<!DOCTYPE html>
<html><head>
	<title>Kill the Royals</title>
	<meta charset="UTF-8">
	<style>
		fieldset table td:first-child { text-align:right }
		fieldset table td:last-child { text-align:left }
	</style>
</head><body style="margin:0;background:black;font-family:sans-serif">

<canvas id="canvas" style="position:fixed"></canvas>
<canvas id="canvas2" style="position:fixed;pointer-events:none"></canvas>
<div style="position:fixed;top:0;left:0;color:white;font-size:70%;background:#444;padding:2px 5px 5px 2px;border-radius: 0 0 10px 0">
	Based on <a href="https://www.pentadact.com/2019-08-20-gridcannon-a-single-player-game-with-regular-playing-cards/" target="_blank" style="color:yellow">Gridcannon</a> by Tom Francis.
	<br>Check link for instructions.
</div>
<div id="option_btn" style="position:fixed;top:0;right:0;color:#ccc;font-size:120%;background:#900;padding:5px 5px 10px 10px;border-radius: 0 0 0 20px;cursor:pointer" onclick="open_options()">options</div>

<div id="options" style="position:absolute;top:0;right:0;color:white;background:#900;padding:15px 15px 20px 20px;border-radius: 0 0 0 20px;text-align:center;display:none;font-size:80%">
	<b style="font-size:150%"><u>&nbsp;OPTIONS&nbsp;</u></b>
	<table style="margin:2em auto"><tr><td valign="top">
		<fieldset><legend>Display</legend>
			<table><tr>
				<td><input type="checkbox" id="show_light"></td>
				<td><label for="show_light">Highlight playable cards</label></td>
			</tr><tr>
				<td><input type="checkbox" id="show_help"></td>
				<td><label for="show_help">Show help</label></td>
			</tr><tr>
				<td><input type="checkbox" id="show_hover"></td>
				<td><label for="show_hover">Show hover tips</label></td>
			</tr><tr>
				<td><input type="checkbox" id="animation"></td>
				<td><label for="animation">Show animations</label></td>
			</tr></table>
		</fieldset>
	</td><td valign="top" rowspan="3">
		<fieldset><legend>Rules</legend>
			<table><tr>
				<td>Maximum value card</td>
				<td><select id="max_value"><option value="10">10</option><option value="9">9</option><option value="8">8</option></select></td>
			</tr><tr>
				<td>Number of Joker pairs</td>
				<td><select id="num_jokers"><option value="2">2</option><option value="1">1</option><option value="0">0</option></select></td>
			</tr><tr>
				<td>Number of Blue Jokers</td>
				<td><select id="free_joker"><option value="2">2</option><option value="1">1</option><option value="0">0</option></select></td>
			</tr><tr>
				<td>While building, place cards</td>
				<td><select id="place_anygrid"><option value="1">anywhere</option><option value="0">in order</option></select></td>
			</tr><tr>
				<td>While building, skip</td>
				<td><select id="skip_center"><option value="1">center</option><option value="0">nothing</option></select></td>
			</tr><tr>
				<td>Place enemies</td>
				<td><select id="place_anyenemy"><option value="1">anywhere</option><option value="0">near most similar card</option></select></td>
			</tr><tr>
				<td>When adding cards to deck</td>
				<td><select id="deck_shuffle"><option value="0">don't shuffle</option><option value="1">shuffle new cards</option><option value="2">shuffle whole deck</option></select></td>
			</tr><tr>
				<td>On pile reset, jokers</td>
				<td><select id="joker_once"><option value="0">remain</option><option value="1">are removed</option></select></td>
			</tr><tr>
				<td>On pile reset, aces</td>
				<td><select id="ace_once"><option value="0">remain</option><option value="1">are removed</option></select></td>
			</tr><tr>
				<td>Jokers try to go</td>
				<td><select id="joker_color"><option value="0">anywhere</option><option value="1">to same color</option></select></td>
			</tr><tr>
				<td>Aces try to go</td>
				<td><select id="ace_color"><option value="0">anywhere</option><option value="1">to same color</option><option value="2">to same suit</option></select></td>
			</tr><tr>
				<td>Attacks</td>
				<td><select id="armor_pierce"><option value="1">can remove armor</option><option value="0">must kill enemy</option></select></td>
			</tr></table>
			<!-- <button onclick="set_options(0)">Easiest</button> <button onclick="set_options(1)">Standard</button> <button onclick="set_options(2)">Hardest</button> -->
		</fieldset>
	</td></tr><tr><td valign="bottom">
		<fieldset><legend>Automation</legend>
			<table><tr>
				<td><input type="checkbox" id="auto_draw"></td>
				<td><label for="auto_draw">Auto-draw from main deck</label></td>
			</tr><tr>
				<td><input type="checkbox" id="auto_build"></td>
				<td><label for="auto_build">Auto-build, if possible</label></td>
			</tr><tr>
				<td><input type="checkbox" id="auto_space"></td>
				<td><label for="auto_space">Tap 'space' to make a forced move</label></td>
			</tr></table>
		</fieldset>
	</td></tr></table>
	<button style="font-size:100%;padding:3px 2em;margin:0 1em" onclick="close_options(true)">Start New Game</button>
	<button style="font-size:100%;padding:3px 2em;margin:0 1em" onclick="close_options(false)">Close</button>

</div>

<script>
"use strict";

var ANIMATION_TIME = 15;

const Config = {
	// display
	show_help:   true, // show help
	show_hover: false, // show info on grid and royals, when hovering
	show_light:  true, // highlights playable cards
	animation:   true, // show animations

	// automation
	auto_draw:  false, // automatically draw card from deck (if it's the only option and it has cards available)
	auto_build: false, // automatically perform forced building moves
	auto_space:  true, // if there is a single option available, tap 'space' to play it

	// rules
	max_value:     10, // use card numbers up to this value (8, 9 or 10)
	num_jokers:     1, // jokers of each color
	free_joker:     0, // blue jokers
	place_anygrid:  0, // on building phase, allow to place card in any empty grid pile
	skip_center:    1, // on building phase, do not fill the center
	place_anyenemy: 0, // allow placing royals on any enemy position
	deck_shuffle:   0, // shuffle cards when adding to deck? 0:no, 1:yes, 2:shuffle whole deck
	joker_once:     0, // when resetting a pile, a joker is removed (except when played over an ace, joker, or empty grid)
	ace_once:       0, // when resetting a pile, an ace is removed (except when played over an ace, joker, or empty grid)
	joker_color:    0, // jokers must be played, preferently, on pile of the same color
	ace_color:      0, // ace must be played, preferently, on pile of the same color. if 2, on pile of the same suit
	armor_pierce:   0, // when an enemy is attacked but not killed, if damage was enough to kill it without armor, remove last card armor (removes 'enemy too strong' lose condition)
};
const ConfigDefault = {};
for (let key in Config) ConfigDefault[key] = Config[key];

var helpText = "";
var hovering = null;


var sprites = new Image();
sprites.src = "cards.png";

var canvas = document.getElementById("canvas");
var canvas2 = document.getElementById("canvas2");
var ctx = canvas.getContext("2d");
var ctx2 = canvas2.getContext("2d");


const W = 140;
const H = 190;
const S = 5; // small separation between grid cards
const SS = 20; // medium separation between grid and royals
const SSS = 50; // big separation between areas
const BORDER = 10;
const HELPSIZE = 50;

// position of central card
const Cx = BORDER + W*3 + S+SS + SSS + H;
const Cy = BORDER + H*3 + S+SS;

// position of shame pile
const Sx = Cx+Cx-H/2 - BORDER;
const Sy = BORDER + W;

// position of main deck
const Dx = BORDER + H/2;
const Dy = Cy;


function resize_canvas() {
	canvas.width = BORDER*2 + W*6+S*2+SS*2+SSS*2+H*2;
	canvas.height = BORDER*2 + H*6+S*2+SS*2 + Config.show_help*HELPSIZE;
	canvas2.width = canvas.width;
	canvas2.height = canvas.height;

	ctx.font = "30px serif";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
}
resize_canvas();


const backSprite = [16,2];
const HIGHLIGHT_DRAW = "yellow"; // draw from main deck (clickable)
const HIGHLIGHT_DRAWTO = "blue"; // moving from main deck
const HIGHLIGHT_SHAME = "red"; // send to shame (clickable)
const HIGHLIGHT_CLEAR = "cyan"; // clear a grid (clickable)
const HIGHLIGHT_EXTRA = "blue"; // moving royal from extra
const HIGHLIGHT_TOEXTRAR = "yellow"; // moving royal to extra (clickable)
const HIGHLIGHT_TOEXTRA = "yellow"; // moving card to extra (clickable)
const HIGHLIGHT_NENEMY = "yellow"; // flush extra into main deck (clickable)
const HIGHLIGHT_ARMOR = "red"; // send to armor (clickable)
const HIGHLIGHT_BUILD = "white"; // send card to play area while building (clickable)
const HIGHLIGHT_NEWENEMY = "white"; // send royal to play area (clickable)
const HIGHLIGHT_TOGRID = "yellow"; // send card to play area (clickable)
const HIGHLIGHT_RANOUT = "red"; // clear a grid after ran out of cards (clickable)





let canvasW;
let canvasH;
(window.onresize = function() {
	const realW = canvas.width;
	const realH = canvas.height;

	const windowH = window.innerHeight;
	const windowW = window.innerWidth;

	const ratioWH = realW / realH;
	const ratioHW = realH / realW;

	canvasW = (windowH * ratioWH < windowW) ? windowH*ratioWH : windowW;
	canvasH = (windowH * ratioWH > windowW) ? windowW*ratioHW : windowH;

	canvas2.style.width  = canvas.style.width  = canvasW + "px";
	canvas2.style.height = canvas.style.height = canvasH + "px";

	canvas2.style.left = canvas.style.left = ((windowW - canvasW) / 2) + "px";
	canvas2.style.top  = canvas.style.top  = ((windowH - canvasH) / 2) + "px";
})();



class Card {
	// suits
	static get Diamonds() { return ["♦",  "R",  0]; }
	static get Hearts()   { return ["♥",  "R",  1]; }
	static get Spades()   { return ["♠",  "B",  2]; }
	static get Clubs()    { return ["♣",  "B",  3]; }
	// "suits" for jokers
	static get Red()      { return [null, "R",  0]; }
	static get Black()    { return [null, "B",  1]; }
	static get Blue()     { return [null, null, 2]; }

	constructor(value,suit,color, frontSprite,backSprite, shown=false) {
		this._value = value;
		this._suit = suit;
		this._color = color;
		this._frontSprite = frontSprite;
		this._backSprite = backSprite;
		this._shown = shown;
	}
	static newValueCard(value, [suit,color,Y], backSprite, shown=false) {
		return new Card(value,suit,color,[value,Y],backSprite, shown);
	}
	get value() {
		return this._value;
	}
	get suit() {
		return this._suit;
	}
	get color() {
		return this._color;
	}
	get sprite() {
		return this._shown ? this._frontSprite : this._backSprite;
	}
	get shown() {
		return this._shown;
	}
	get show() {
		this._shown = true;
		return this;
	}
	get hide() {
		this._shown = false;
		return this;
	}
	get flip() {
		this._shown = !this._shown;
		return this;
	}

	static get build_deck() {
		const deck = [];

		// value cards
		[Card.Diamonds, Card.Hearts, Card.Spades, Card.Clubs].forEach(suit => {
			for (let value = 1; value <= 13; value++) {
				if (value < 11 && value > Config.max_value) continue;
				deck.push(Card.newValueCard(value, suit, backSprite, true));
			}
		})

		// jokers
		for (let i=0; i<Config.num_jokers; i++) {
			deck.push(Card.newValueCard(0, Card.Black, backSprite, true));
			deck.push(Card.newValueCard(0, Card.Red,   backSprite, true));
		}
		for (let i=0; i<Config.free_joker; i++) {
			deck.push(Card.newValueCard(0, Card.Blue,  backSprite, true));
		}

		return deck;
	}

	// a special 'card' to show the outline of a card
	static get none() {
		return new Card(null,null,null, [0,3], [0,3]);
	}
}


// represents a pile of cards
// a pile has a position on the canvas, and a "spill area" on where to paint extra cards
class Pile {
	constructor(name,type, [x,y], [spillX,spillY]=[0,0], spillSingle=Math.max(Math.abs(spillX),Math.abs(spillY)), spillMax=Infinity) {
		this._name = name;
		this._type = type;
		// card list
		this._cards = [];
		// show outline when empty?
		this._outline = false;
		// rotation
		this._rotate = false;
		// where to show card?
		this._x = x;
		this._y = y;
		// up to where to show other cards? (at most one can be non-zero)
		if (spillX !== 0 && spillY !== 0) throw("spillX & spillY");
		this._spillX = spillX;
		this._spillY = spillY;
		if (this._spillX || this._spillY) {
			if (Math.abs(this._spillX) > Math.max(canvas.width,canvas.height))
				this._spillX = Math.max(canvas.width,canvas.height) * Math.sign(this._spillX);
			if (Math.abs(this._spillY) > Math.max(canvas.width,canvas.height))
				this._spillY = Math.max(canvas.width,canvas.height) * Math.sign(this._spillY);

			// desired space until next card
			this._spillSingle = Math.abs(spillSingle);
			const maxSingle = this._spillX ? W : H;
			if (!this._spillSingle || this._spillSingle>maxSingle)
				this._spillSingle = maxSingle;
			// show no more than this number of cards
			this._spillMax = spillMax;
		} else {
			this._spillSingle = 0;
			this._spillMax = 0;
		}

		Pile.list.set(name, this);
	}
	get showOutline() { this._outline = true;  return this; }
	get hideOutline() { this._outline = false; return this; }
	get sideways() { this._rotate = true; return this; }
	isHere(x,y) {
		const [width,height] = this._rotate ? [H,W] : [W,H];

		// is the main card in the given coordinates?
		if (x < this._x-width/2 || y < this._y-height/2) return false;
		if (x > this._x+width/2 || y > this._y+height/2) return false;

		return true;
	}

	get name() { return this._name; }
	get type() { return this._type; }

	get length() { return this._cards.length; }
	push(v) { return this._cards.push(v); }
	unshift(v) { return this._cards.unshift(v); }
	pop() { return this._cards.pop(); }
	shift() { return this._cards.shift(); }
	get topCard() { return this._cards.length ? this._cards.slice(-1)[0] : null; }

	// sum of all values in pile
	get totalValue() {
		return this._cards.reduce( (hp,card) => hp+card.value, 0 );
	}

	paintTip() {
		if (!this.length) return;
		if (this._type !== "C" && this._type !== "R") return;

		const grad = ctx.createRadialGradient(this._x,this._y,0, this._x,this._y,Math.max(W,H));

		if (this._type === "C") {
			// show number of cards
			grad.addColorStop(0, "rgba(0,0,255,.7)");
			grad.addColorStop(1, "rgba(0,0,255,.2)");
			ctx.fillStyle = grad;
			ctx.fillRect(this._x-W/2, this._y-H/2, W,H);

			ctx.fillStyle = "white";
			if (this.length>1)
				ctx.fillText( this.length+" cards", this._x, this._y );
			else
				ctx.fillText( "1 card", this._x, this._y );
		} else {
			// show total life
			if (!this.topCard.shown) return;

			grad.addColorStop(0, "rgba(255,0,0,.7)");
			grad.addColorStop(1, "rgba(255,0,0,.2)");
			ctx.fillStyle = grad;
			ctx.fillRect(this._x-W/2, this._y-H/2, W,H);

			ctx.fillStyle = "white";
			ctx.fillText( "Life: "+this.totalValue, this._x, this._y );
		}
	}

	shuffle() {
		const pile = this._cards;
		for (let i = pile.length-1; i > 0; i--) {
			const j = Math.floor(Math.random() * (i+1));
			[ pile[i],pile[j] ] = [ pile[j],pile[i] ];
		}
	}

	static paint(card, x,y) {
		const [sx,sy] = card.sprite;
		ctx.drawImage(sprites, sx*W,sy*H,W,H, x,y,W,H);
	}

	paint() {
		ctx.save();
		ctx.translate(this._x, this._y);
		if (this._rotate) ctx.rotate(Math.PI/2);

		if (0) {
			ctx.fillStyle = "blue";
			ctx.fillRect(Math.min(this._spillX,0)-W/2, Math.min(this._spillY,0)-H/2, W+Math.abs(this._spillX,0),H+Math.abs(this._spillY,0));
		}

		if (!this._cards.length) {
			if (this._outline)
				Pile.paint(Card.none, -W/2,-H/2);
		} else if (this._cards.length === 1 || !this._spillMax) {
			Pile.paint(this._cards[this._cards.length-1], -W/2,-H/2);
		} else {
			const toShow = this._cards.slice(-(1+this._spillMax));
			const extras = toShow.length - 1;
			let [dx,dy] = [this._spillX/extras,this._spillY/extras];
			if (Math.abs(dx) > this._spillSingle) dx = this._spillSingle * Math.sign(dx);
			if (Math.abs(dy) > this._spillSingle) dy = this._spillSingle * Math.sign(dy);
			let [sx,sy] = [dx*extras-W/2, dy*extras-H/2];
			toShow.forEach(card => {
				Pile.paint(card, sx,sy);
				sx -= dx;
				sy -= dy;
			});
		}

		ctx.restore();
	}

	highlight(color) {
		if (!Config.show_light) return;

		ctx2.fillStyle = color;

		ctx2.save();
		ctx2.translate(this._x, this._y);
		if (this._rotate) ctx2.rotate(Math.PI/2);

		ctx2.fillRect(-W/2, -H/2, W,H);

		ctx2.restore();
	}

	static get(name) {
		return Pile.list.get(name);
	}
	static getRoyals() {
		const R = [];
		Pile.list.forEach(pile => {
			if (pile.type === "R") R.push(pile);
		});
		return R;
	}
	static getGrids() {
		const R = [];
		Pile.list.forEach(pile => {
			if (pile.type === "C") R.push(pile);
		});
		return R;
	}

	static clearAll() {
		Pile.list.forEach(pile => pile._cards = []);
	}
}
Pile.list = new Map;

new Pile("RoyalT1","R", [Cx-1*(W+S), Cy-2*H-S-SS], [0,-H/2], H/4);
new Pile("RoyalT2","R", [Cx+0*(W+S), Cy-2*H-S-SS], [0,-H/2], H/4);
new Pile("RoyalT3","R", [Cx+1*(W+S), Cy-2*H-S-SS], [0,-H/2], H/4);
new Pile("RoyalB1","R", [Cx-1*(W+S), Cy+2*H+S+SS], [0, H/2], H/4);
new Pile("RoyalB2","R", [Cx+0*(W+S), Cy+2*H+S+SS], [0, H/2], H/4);
new Pile("RoyalB3","R", [Cx+1*(W+S), Cy+2*H+S+SS], [0, H/2], H/4);
new Pile("RoyalR1","R", [Cx+2*W+S+SS, Cy-1*(H+S)], [ W/2,0], W/4);
new Pile("RoyalR2","R", [Cx+2*W+S+SS, Cy+0*(H+S)], [ W/2,0], W/4);
new Pile("RoyalR3","R", [Cx+2*W+S+SS, Cy+1*(H+S)], [ W/2,0], W/4);
new Pile("RoyalL1","R", [Cx-2*W-S-SS, Cy-1*(H+S)], [-W/2,0], W/4);
new Pile("RoyalL2","R", [Cx-2*W-S-SS, Cy+0*(H+S)], [-W/2,0], W/4);
new Pile("RoyalL3","R", [Cx-2*W-S-SS, Cy+1*(H+S)], [-W/2,0], W/4);

new Pile("Grid11","C", [Cx-1*(W+S), Cy-1*(H+S)]).showOutline;
new Pile("Grid21","C", [Cx+0*(W+S), Cy-1*(H+S)]).showOutline;
new Pile("Grid31","C", [Cx+1*(W+S), Cy-1*(H+S)]).showOutline;
new Pile("Grid12","C", [Cx-1*(W+S), Cy+0*(H+S)]).showOutline;
new Pile("Grid22","C", [Cx+0*(W+S), Cy+0*(H+S)]).showOutline;
new Pile("Grid32","C", [Cx+1*(W+S), Cy+0*(H+S)]).showOutline;
new Pile("Grid13","C", [Cx-1*(W+S), Cy+1*(H+S)]).showOutline;
new Pile("Grid23","C", [Cx+0*(W+S), Cy+1*(H+S)]).showOutline;
new Pile("Grid33","C", [Cx+1*(W+S), Cy+1*(H+S)]).showOutline;

new Pile("Deck",null, [Dx,Dy]).showOutline.sideways;
new Pile("Extra",null, [Dx,Dy+H+S],[Dy-H-S-W/2-BORDER,0],W/4,Infinity).sideways;

//new Pile("Shame",null, [Sx,Sy],[W*6,0],W/4,Infinity).sideways;
new Pile("Shame",null, [Sx,Sy],[Cy*2-Sy*2,0],W/4,Infinity).sideways;



function findPile(x,y) {
	for (const [name,pile] of Pile.list)
		if (pile.isHere(x,y)) return pile;
	return null;
}

function writeShame() {
	const numShames = Pile.get("Shame").length;
	ctx.fillStyle = "white";
	if (numShames)
		ctx.fillText("Shames: "+numShames, Sx,(Sy-W/2)/2);
}

var flipping_deck = false; // ugly hack
function writeLeft() {
	ctx.fillStyle = 'white';
	ctx.fillText("Left: "+(Pile.get("Deck").length+flipping_deck), Dx,(Dy-W/2)-32);
}

function writeHelp() {
	if (Config.show_help) {
		ctx.fillStyle = "rgba(0,0,255,.3)";
		ctx.fillRect(0,Cy+Cy,canvas.width,HELPSIZE);
		ctx.fillStyle = "white";
		ctx.fillText(helpText, Cx,Cy+Cy+HELPSIZE/2);
	}
}

function repaint_all(rehighlight=true) {
	ctx.fillStyle = "#222";
	ctx.fillRect(0,0,canvas.width,canvas.height);
	ctx.fillStyle = "#333";
	ctx.fillRect(Cx-W/2-S-W-SS-W-W/2-SSS/2,0,(W+S*2+W*2+SS*2+W*2+W+SSS),Cy+Cy);
	Pile.list.forEach(pile => pile.paint());
	writeShame();
	writeLeft();
	writeHelp();

	if (Config.show_hover && hovering) {
		hovering.paintTip();
	}

	if (rehighlight) {
		clear_highlights();
		highlights.forEach(([namepile,color,valid=true]) => {
			const pile = (typeof namepile === "string") ? Pile.get(namepile) : namepile;
			if (valid)
				valid_clicks.add(pile);
		});
		start_highlights();
	}
}



var options_opened = false;
function open_options() {
	options_opened = true;
	document.getElementById("options").style.display = "";
	document.getElementById("option_btn").style.display = "none";

	for (let key in Config) {
		if (Config[key] === true || Config[key] === false)
			document.getElementById(key).checked = Config[key];
		else
			document.getElementById(key).value = Config[key];
	}
}

function close_options(newgame) {
	if (animating && newgame) return;

	for (let key in Config) {
		if (Config[key] === true || Config[key] === false)
			Config[key] = !!document.getElementById(key).checked;
		else
			Config[key] = +document.getElementById(key).value;
	}

	document.getElementById("option_btn").style.display = "";
	document.getElementById("options").style.display = "none";
	options_opened = false;


	resize_canvas();
	window.onresize();

	if (newgame)
		new_game();
	else
		repaint_all();
}

function set_options(diff) {
	for (let key in Config) {
		if (Config[key] === true || Config[key] === false) continue;

		let theSelect = document.getElementById(key);
		if (diff === 0)
			theSelect.value = theSelect.options[ 0 ].value;
		if (diff === 1)
			theSelect.value = ConfigDefault[key];
		if (diff === 2)
			theSelect.value = theSelect.options[ theSelect.options.length-1 ].value;
	}
}





var opacity = 0;
var opacity_d = null;
var highlights = [];
var high_timeout = null;
function highlight_opacity() {
	if (opacity <= 20) opacity_d = 2;
	if (opacity >= 50) opacity_d = -2;
	opacity = opacity + opacity_d;
	canvas2.style.opacity = opacity/100;
}
function clear_highlights() {
	opacity = 0;
	ctx2.clearRect(0,0,canvas.width,canvas.height);
	stop_highlight();
}
function stop_highlight() {
	if (high_timeout) clearInterval(high_timeout);
	ctx2.clearRect(0,0,canvas.width,canvas.height);
	canvas2.style.opacity = 1;
}
function start_highlights() {
	stop_highlight();
	ctx2.clearRect(0,0,canvas.width,canvas.height);

	highlights.forEach(([namepile,color]) => {
		const pile = (typeof namepile === "string") ? Pile.get(namepile) : namepile;
		pile.highlight(color);
	});

	highlight_opacity();
	high_timeout = setInterval(() => {
		highlight_opacity();
	}, 50);
}




window.onload = () => {

	canvas.onclick = (e) => {
		// get the real mouse position
		const [x,y] = [ e.layerX*canvas.width/canvasW, e.layerY*canvas.height/canvasH ];
		const pile = findPile(x,y);
		if (pile)
			clicked(pile);
	}
	canvas.onmousemove = (e) => {
		// get the real mouse position
		const [x,y] = [ e.layerX*canvas.width/canvasW, e.layerY*canvas.height/canvasH ];
		const pile = findPile(x,y);
		if (hovering === pile) return;
		hovering = pile;
		canvas.style.cursor = valid_clicks.has(hovering) ? "pointer" : "";
		repaint_all(false);
	}

	document.body.onkeyup = e => {
		// if a single card is clickable, click it when 'space' is pressed
		if (!Config.auto_space) return;
		if (e.keyCode !== 32) return;
		if (valid_clicks.size !== 1) return;
		clicked( valid_clicks.values().next().value );
	}

	new_game();

}


function new_game() {
	state = STATE_ZERO;
	Pile.clearAll();
	Card.build_deck.forEach(card => Pile.get("Deck").push(card.hide));
	Pile.get("Deck").shuffle();
	clicked(null);
}



// given a royal card, returns piles of valid enemy positions for it
function findEnemyPos(givenCard) {
	const grids = []; // array; each element has: [card at grid (can be null), royalname]

	if ( !Pile.get("RoyalT1").topCard ) grids.push( [Pile.get("Grid11").topCard, "RoyalT1"] );
	if ( !Pile.get("RoyalT2").topCard ) grids.push( [Pile.get("Grid21").topCard, "RoyalT2"] );
	if ( !Pile.get("RoyalT3").topCard ) grids.push( [Pile.get("Grid31").topCard, "RoyalT3"] );

	if ( !Pile.get("RoyalR1").topCard ) grids.push( [Pile.get("Grid31").topCard, "RoyalR1"] );
	if ( !Pile.get("RoyalR2").topCard ) grids.push( [Pile.get("Grid32").topCard, "RoyalR2"] );
	if ( !Pile.get("RoyalR3").topCard ) grids.push( [Pile.get("Grid33").topCard, "RoyalR3"] );

	if ( !Pile.get("RoyalB1").topCard ) grids.push( [Pile.get("Grid13").topCard, "RoyalB1"] );
	if ( !Pile.get("RoyalB2").topCard ) grids.push( [Pile.get("Grid23").topCard, "RoyalB2"] );
	if ( !Pile.get("RoyalB3").topCard ) grids.push( [Pile.get("Grid33").topCard, "RoyalB3"] );

	if ( !Pile.get("RoyalL1").topCard ) grids.push( [Pile.get("Grid11").topCard, "RoyalL1"] );
	if ( !Pile.get("RoyalL2").topCard ) grids.push( [Pile.get("Grid12").topCard, "RoyalL2"] );
	if ( !Pile.get("RoyalL3").topCard ) grids.push( [Pile.get("Grid13").topCard, "RoyalL3"] );

	let best = -1;
	let bestList = [];
	if (Config.place_anyenemy) {
		grids.forEach(([card,pos]) => {
			bestList.push(Pile.get(pos));
		});
	} else {
		grids.forEach(([card,pos]) => {
			let value;
			if (!card) value = 0; // IDEA: use -1 to make it lower than jokers?
			else if (givenCard.suit === card.suit) value = 40 + card.value; // 1. highest value card of the same suit
			else if (givenCard.color === card.color) value = 20 + card.value; // 2. highest value card of same colour
			else value = card.value; // 3. higuest value card

			if (value > best) { best = value; bestList = []; }
			if (value === best) bestList.push(Pile.get(pos));
		});
	}

	return bestList;
}


// given a grid pile, attacks available enemies
function checkAttacks(pile) {
	[ // trigger, ammo1,ammo2, target
		[ "Grid13", "Grid12","Grid11", "RoyalT1" ],
		[ "Grid23", "Grid22","Grid21", "RoyalT2" ],
		[ "Grid33", "Grid32","Grid31", "RoyalT3" ],
		[ "Grid11", "Grid21","Grid31", "RoyalR1" ],
		[ "Grid12", "Grid22","Grid32", "RoyalR2" ],
		[ "Grid13", "Grid23","Grid33", "RoyalR3" ],
		[ "Grid31", "Grid21","Grid11", "RoyalL1" ],
		[ "Grid32", "Grid22","Grid12", "RoyalL2" ],
		[ "Grid33", "Grid23","Grid13", "RoyalL3" ],
		[ "Grid11", "Grid12","Grid13", "RoyalB1" ],
		[ "Grid21", "Grid22","Grid23", "RoyalB2" ],
		[ "Grid31", "Grid32","Grid33", "RoyalB3" ],
	].forEach(([trigger, ammo1,ammo2, targetname]) => {
		if (pile.name !== trigger) return;

		const targetpile = Pile.get(targetname);
		const target = targetpile.topCard;
		if (!target || !target.shown) return;

		let damage = 0;
		[ Pile.get(ammo1).topCard, Pile.get(ammo2).topCard ].forEach(ammo => {
			if (!ammo) return;
			if (target.value >= 12 && target.color !== ammo.color) return;
			if (target.value >= 13 && target.suit !== ammo.suit) return;
			damage += ammo.value;
		});

		if (damage >= targetpile.totalValue) {
			animate_destroy(target, targetpile);
			then(() => {
				while (targetpile.length) targetpile.shift();
			});
			animate_flip(target, targetpile, false);
			then(() => {
				targetpile.push(target.hide);
			});
		} else if (Config.armor_pierce && damage >= target.value) {
			animate_destroy(targetpile.topCard, targetpile);
			then(() => {
				targetpile.shift(); // remove one armor
			});
		}
	});
}


// add pile to main deck
function add2deck(pile) {
	if (!pile.length) return;

	const card = pile.topCard; // to show in animation
	const temp = [];

	then(() => {
		if (Config.deck_shuffle === 1) pile.shuffle();
		while (pile.length)
			temp.push(pile.shift());
	});
	animate_flip(card, pile, false);
	animate_move(card, pile, Pile.get("Deck"), true);
	then(() => {
		while (temp.length)
			Pile.get("Deck").unshift( temp.shift().hide );
		if (Config.deck_shuffle === 2) Pile.get("Deck").shuffle();
	});
}





const STATE_ZERO        =  0; // game hasn't started yet
const STATE_BUILD_DRAW  =  1; // building the game. Waiting to draw
const STATE_BUILD_ROYAL =  2; // building the game. Waiting to put royal on extra deck
const STATE_BUILD_CARD  =  3; // building the game. Waiting to put normal on next free grid pile
const STATE_BUILD_ENEMY =  4; // building the game. Waiting to put royal on attack position
const STATE_MAIN_DRAW   =  5; // main game. Waiting to draw
const STATE_MAIN_ENEMY  =  6; // main game. Waiting to put royal on attack position
const STATE_MAIN_NENEMY =  7; // main game. New enemy! Flush extra into deck
const STATE_MAIN_EXTRA  =  8; // main game. No enemies. Send deck to extra
const STATE_MAIN_JOKER  =  9; // main game. Ace or Joker. Put on grid
const STATE_MAIN_TOGRID = 10; // main game. Put card on grid pile
const STATE_MAIN_SHAME  = 11; // main game. Can't place card. Shame or armor?
const STATE_MAIN_CLEAR  = 12; // main game. After shaming, clear a grid pile
const STATE_MAIN_RANOUT = 13; // main game. After running out of cards. Choose a grid pile
const STATE_FINISHED_W  = 14; // game ends (win)
const STATE_FINISHED_L1 = 15; // game ends (out of cards)
const STATE_FINISHED_L2 = 16; // game ends (invincible enemy)

var state = STATE_ZERO;
var valid_clicks = new Set([null]);

function clicked(pile) {
	if (pile && !valid_clicks.has(pile)) return;
	if (options_opened) return;
	valid_clicks.clear();

	let card = null;
	clear_highlights();
	highlights = [];

	switch (state) {

		case STATE_ZERO: {
			state = STATE_BUILD_DRAW;
			break;
		}

		case STATE_BUILD_DRAW: {
			card = pile.pop();
			flipping_deck = true;
			animate_flip(card, Pile.get("Deck"));
			then(() => {
				flipping_deck = false;
				card.show;
				pile.push(card);
				if (card.value > 10) {
					state = STATE_BUILD_ROYAL;
				} else {
					state = STATE_BUILD_CARD;
				}
			});
			break;
		}

		case STATE_BUILD_ROYAL: {
			card = Pile.get("Deck").pop();
			animate_move(card, Pile.get("Deck"), Pile.get("Extra"));
			then(() => {
				Pile.get("Extra").push(card);
				state = STATE_BUILD_DRAW;
			});
			break;
		}

		case STATE_BUILD_CARD: {
			card = Pile.get("Deck").pop();
			animate_move(card, Pile.get("Deck"), pile);
			then(() => {
				pile.push(card);
				if (Pile.getGrids().filter(pile => !pile.length && (pile.name !== "Grid22" || !Config.skip_center)).length) {
					state = STATE_BUILD_DRAW;
				} else {
					if (Pile.get("Extra").length) {
						state = STATE_BUILD_ENEMY;
					} else {
						state = STATE_MAIN_DRAW;
					}
				}
			});
			break;
		}

		case STATE_BUILD_ENEMY: {
			card = Pile.get("Extra").pop();
			animate_move(card, Pile.get("Extra"), pile);
			then(() => {
				pile.push(card);
				if (Pile.get("Extra").length) {
					state = STATE_BUILD_ENEMY;
				} else {
					state = STATE_MAIN_DRAW;
				}
			});
			break;
		}

		case STATE_MAIN_DRAW: {
			if ( !pile.topCard ) {
				// after ran out of cards in deck: choose a stack. Put its top card on Shame Pile, take the rest as new deck.
				const grids = Pile.getGrids().filter(pile => pile.length > 1);
				if (!grids.length)
					state = STATE_FINISHED_L1;
				else
					state = STATE_MAIN_RANOUT;
				break;
			}
			card = pile.pop();
			flipping_deck = true;
			animate_flip(card, Pile.get("Deck"));
			then(() => {
				flipping_deck = false;
				card.show;
				pile.push(card);
				if (card.value > 10) {
					// if royal: put on some attack position
					state = STATE_MAIN_ENEMY;
				} else {
					if (!Pile.getRoyals().filter( pile => pile.topCard && pile.topCard.shown ).length) {
						// if no enemies left, put on extra deck
						state = STATE_MAIN_EXTRA;
					} else if (card.value <= 1) {
						// - if Ace or Joker, must be put on any grid pile.
						state = STATE_MAIN_JOKER;
					} else {
						// valid grid positions for the current card
						const grids = Pile.getGrids().filter( pile => !pile.topCard || pile.topCard.value <= card.value );

						if (grids.length) {
							// can be put on any grid card of same or lesser value
							state = STATE_MAIN_TOGRID;
						} else {
							// can be put on any enemy or in the 'shame' pile
							state = STATE_MAIN_SHAME;
						}
					}
				}
			});
			break;
		}

		case STATE_MAIN_ENEMY: {
			card = Pile.get("Deck").pop();
			animate_move(card, Pile.get("Deck"), pile);
			then(() => {
				pile.push(card);

				if (Pile.get("Extra").length) {
					// move extra deck into main deck
					state = STATE_MAIN_NENEMY;
				} else {
					state = STATE_MAIN_DRAW;
				}
			});
			break;
		}

		case STATE_MAIN_NENEMY: {
			add2deck(Pile.get("Extra"));
			state = STATE_MAIN_DRAW;
			break;
		}

		case STATE_MAIN_EXTRA: {
			card = Pile.get("Deck").pop();
			animate_move(card, Pile.get("Deck"), pile);
			then(() => {
				pile.push(card);
				state = STATE_MAIN_DRAW;
			});
			break;
		}

		case STATE_MAIN_JOKER: {
			card = Pile.get("Deck").topCard;

			let discard = false;
			if ( (card.value === 0 && Config.joker_once) || (card.value === 1 && Config.ace_once) ) {
				discard = true;
				// ace/joker must be discarded unless pile is empty or has a single joker or ace
				if ( pile.length === 0 || (pile.length === 1 && pile.topCard.value <= 1) )
					discard = false;
			}

			// get all cards in pile and add to Deck
			add2deck(pile);

			// put ace/joker in pile, or discard it
			if (discard) {
				then(() => {
					Pile.get("Deck").pop();
				});
				animate_destroy(card, Pile.get("Deck"));
			} else {
				then(() => {
					Pile.get("Deck").pop();
				});
				animate_move(card, Pile.get("Deck"), pile);
				then(() => {
					pile.push(card);
				});
			}

			if (!discard)
				checkAttacks(pile);

			then(() => {
				// check win condition
				if ( Pile.getRoyals().filter(pile => pile.topCard && !pile.topCard.shown).length === 12 )
					state = STATE_FINISHED_W;
				else
					state = STATE_MAIN_DRAW;
			});
			break;
		}

		case STATE_MAIN_TOGRID: {
			card = Pile.get("Deck").pop();
			animate_move(card, Pile.get("Deck"), pile);
			then(() => {
				pile.push(card);
			});

			checkAttacks(pile);

			then(() => {
				// check win condition
				if ( Pile.getRoyals().filter(pile => pile.topCard && !pile.topCard.shown).length === 12 )
					state = STATE_FINISHED_W;
				else
					state = STATE_MAIN_DRAW;
			});
			break;
		}

		case STATE_MAIN_SHAME: {
			card = Pile.get("Deck").pop();
			if (pile.name === "Shame") {
				animate_move(card, Pile.get("Deck"), Pile.get("Shame"));
				then(() => {
					pile.push(card);
					state = STATE_MAIN_CLEAR;
				});
				break;
			} else {
				animate_move(card, Pile.get("Deck"), pile, true);
				then(() => {
					pile.unshift(card);
					if ( !Config.armor_pierce && (pile.totalValue > 20 || (pile.totalValue === 20 && pile.topCard.value === 13)) ) {
						// enemy became unkillable
						state = STATE_FINISHED_L2;
					} else {
						state = STATE_MAIN_DRAW;
					}
				});
			}
			break;
		}

		case STATE_MAIN_CLEAR: {
			// get all cards in pile and add to Deck
			add2deck(pile);
			state = STATE_MAIN_DRAW;
			break;
		}

		case STATE_MAIN_RANOUT: {
			// move top of pile to shame, rest to deck
			card = pile.pop();
			animate_move(card, pile, Pile.get("Shame"));
			then(() => {
				Pile.get("Shame").push(card);
			});
			add2deck(pile);
			state = STATE_MAIN_DRAW;
			break;
		}

		case STATE_FINISHED_W:
		case STATE_FINISHED_L1:
		case STATE_FINISHED_L2:
			return;

		default:
			alert("BAD STATE: "+state);
			return;

	}




	then(() => {

		// set help text
		switch (state) {
			case STATE_ZERO:        helpText = ""; break;
			case STATE_BUILD_DRAW:  helpText = "Draw a card from main deck"; break;
			case STATE_BUILD_ROYAL: helpText = "Place Royal on extra deck"; break;
			case STATE_BUILD_CARD:  helpText = "Place card on grid pile"; break;
			case STATE_BUILD_ENEMY: helpText = "Place Royal on enemy position"; break;
			case STATE_MAIN_DRAW:   helpText = "Draw a card from main deck"; break;
			case STATE_MAIN_ENEMY:  helpText = "Place Royal on enemy position"; break;
			case STATE_MAIN_NENEMY: helpText = "Return extra deck to main deck"; break;
			case STATE_MAIN_EXTRA:  helpText = "No enemies present. Send card to extra deck"; break;
			case STATE_MAIN_JOKER:  helpText = "Pick a grid pile to reset"; break;
			case STATE_MAIN_TOGRID: helpText = "Place card on grid pile"; break;
			case STATE_MAIN_SHAME:  helpText = "Can't place card on any grid pile. Armor or Shame?"; break;
			case STATE_MAIN_CLEAR:  helpText = "Pick a grid pile to reset"; break;
			case STATE_MAIN_RANOUT: helpText = "Ran out of cards. Pick a grid pile to reset"; break;
			case STATE_FINISHED_W:  helpText = "The Royals are dead! YOU WIN!"; break;
			case STATE_FINISHED_L1: helpText = "Ran out of cards. YOU LOSE!"; break;
			case STATE_FINISHED_L2: helpText = "The Royals are too powerful! YOU LOSE!"; break;
			default:
				helpText = ""; break;
		}

		// set highlights for new state
		switch (state) {
			case STATE_BUILD_DRAW:
				highlights.push(["Deck", HIGHLIGHT_DRAW]);
				break;
			case STATE_BUILD_ROYAL:
				highlights.push(["Extra", HIGHLIGHT_TOEXTRAR]);
				highlights.push([pile, HIGHLIGHT_DRAWTO, false]);
				break;
			case STATE_BUILD_CARD: {
				const grids = Pile.getGrids().filter(pile => !pile.length && (pile.name !== "Grid22" || !Config.skip_center));
				for (const pile of grids) {
					highlights.push([pile, HIGHLIGHT_BUILD]);
					if (!Config.place_anygrid) break;
				}
				highlights.push([pile, HIGHLIGHT_DRAWTO, false]);
				break;
			}
			case STATE_BUILD_ENEMY:
				highlights.push(["Extra", HIGHLIGHT_EXTRA, false]);
				findEnemyPos(Pile.get("Extra").topCard).forEach(pile => highlights.push([pile, HIGHLIGHT_NEWENEMY]));
				break;
			case STATE_MAIN_DRAW:
				highlights.push(["Deck", HIGHLIGHT_DRAW]);
				break;
			case STATE_MAIN_ENEMY:
				highlights.push(["Deck", HIGHLIGHT_DRAWTO, false]);
				findEnemyPos(card).forEach(pile => highlights.push([pile, HIGHLIGHT_NEWENEMY]));
				break;
			case STATE_MAIN_NENEMY:
				highlights.push(["Extra", HIGHLIGHT_NENEMY]);
				break;
			case STATE_MAIN_EXTRA:
				highlights.push(["Deck", HIGHLIGHT_DRAWTO, false]);
				highlights.push(["Extra", HIGHLIGHT_TOEXTRA]);
				break;
			case STATE_MAIN_JOKER: {
				highlights.push(["Deck", HIGHLIGHT_DRAWTO, false]);

				const restrict = card.value ? Config.ace_color : Config.joker_color; // 2:same suit, 1:same color
				let possiblePiles = [];

				if (restrict >= 2 && card.suit !== null) // must be same suit
					possiblePiles = Pile.getGrids().filter(pile => pile.length && pile.topCard.suit === card.suit);
				if (restrict >= 1 && card.color !== null && !possiblePiles.length) // must be same color
					possiblePiles = Pile.getGrids().filter(pile => pile.length && pile.topCard.color === card.color);
				if (!possiblePiles.length) // must have a card
					possiblePiles = Pile.getGrids().filter(pile => pile.length);
				Pile.getGrids().filter(pile => !pile.length).forEach(pile => possiblePiles.push(pile)); // add all empty piles

				possiblePiles.forEach(pile => highlights.push([pile, HIGHLIGHT_CLEAR]));
				break;
			}
			case STATE_MAIN_TOGRID: {
				highlights.push(["Deck", HIGHLIGHT_DRAWTO, false]);
				Pile.getGrids().filter( pile => !pile.topCard || pile.topCard.value <= card.value ).forEach(pile => highlights.push([pile, HIGHLIGHT_TOGRID]));
				break;
			}
			case STATE_MAIN_SHAME: {
				highlights.push(["Deck", HIGHLIGHT_DRAWTO, false]);
				Pile.getRoyals().filter( pile => pile.topCard && pile.topCard.shown ).forEach(pile => highlights.push([pile, HIGHLIGHT_ARMOR]));
				highlights.push(["Shame", HIGHLIGHT_SHAME]);
				break;
			}
			case STATE_MAIN_CLEAR:
				Pile.getGrids().filter(pile => pile.length).forEach(pile => highlights.push([pile, HIGHLIGHT_CLEAR]));
				break;
			case STATE_MAIN_RANOUT: {
				const grids = Pile.getGrids().filter(pile => pile.length > 1);
				grids.forEach(pile => highlights.push([pile, HIGHLIGHT_RANOUT]));
				break;
			}
		}

		repaint_all();

		// announce victory or defeat
		switch (state) {
			case STATE_FINISHED_W:  alert("YOU WIN!"); break;
			case STATE_FINISHED_L1: alert("YOU LOSE!"); break;
			case STATE_FINISHED_L2: alert("YOU LOSE!"); break;
		}

	});

	stop_highlight();
	do_animation();
}


var animations = [];
function animate_flip(card, pile, show=true) {
	if (!Config.animation) return;

	let f = function(percent) {
		ctx2.clearRect(0,0,canvas.width,canvas.height);

		ctx2.save();
		ctx2.translate(pile._x, pile._y);
		if (pile._rotate) ctx2.rotate(Math.PI/2);
		ctx2.scale(percent,1);

		const [sx,sy] = card.sprite;
		ctx2.drawImage(sprites, sx*W,sy*H,W,H, -W/2,-H/2,W,H);

		ctx2.restore();
	}

	show ? card.hide : card.show;

	let flippage = 100 - 5;
	let ff = () => {
		if (flippage<0) show ? card.show : card.hide;
		f(Math.abs(flippage)/100);
		flippage -= 10;
		if (flippage > -100)
			setTimeout(ff, ANIMATION_TIME);
		else
			setTimeout(do_animation, ANIMATION_TIME);
	}
	animations.push(ff);
}
function animate_move(card, pile_from, pile_to, put_below=false) {
	if (!Config.animation) return;

	let f = function(percent) {
		ctx2.clearRect(0,0,canvas.width,canvas.height);

		ctx2.save();
		ctx2.translate(pile_from._x*(1-percent)+pile_to._x*percent, pile_from._y*(1-percent)+pile_to._y*percent);
		let angle_from = pile_from._rotate ? Math.PI/2 : 0;
		let angle_to = pile_to._rotate ? Math.PI/2 : 0;
		ctx2.rotate(angle_from*(1-percent)+angle_to*percent);

		const [sx,sy] = card.sprite;
		ctx2.drawImage(sprites, sx*W,sy*H,W,H, -W/2,-H/2,W,H);

		ctx2.restore();

		if (put_below && pile_to.topCard) {
			ctx2.save();
			ctx2.translate(pile_to._x, pile_to._y);
			if (pile_to._rotate) ctx2.rotate(Math.PI/2);

			const [sx,sy] = pile_to.topCard.sprite;
			ctx2.drawImage(sprites, sx*W,sy*H,W,H, -W/2,-H/2,W,H);

			ctx2.restore();
		}
	}

	let percent = 0 + 5;
	let ff = () => {
		f(percent/100);
		percent += 5;
		if (percent < 100)
			setTimeout(ff, ANIMATION_TIME);
		else
			setTimeout(do_animation, ANIMATION_TIME);
	}
	animations.push(ff);
}
function animate_destroy(card, pile) {
	if (!Config.animation) return;

	let f = function(percent) {
		ctx2.clearRect(0,0,canvas.width,canvas.height);

		ctx2.save();
		ctx2.translate(pile._x, pile._y);
		if (pile._rotate) ctx2.rotate(Math.PI/2);

		ctx2.scale(1+percent,1+percent);
		ctx2.globalAlpha = 1-percent;

		const [sx,sy] = card.sprite;
		ctx2.drawImage(sprites, sx*W,sy*H,W,H, -W/2,-H/2,W,H);

		ctx2.restore();
	}

	let percent = 0 + 5;
	let ff = () => {
		f(percent/100);
		percent += 5;
		if (percent < 100)
			setTimeout(ff, ANIMATION_TIME);
		else
			setTimeout(do_animation, ANIMATION_TIME);
	}
	animations.push(ff);
}
function then(f) {
	animations.push(() => {
		f();
		do_animation();
	});
}

var animating = false;
function do_animation() {
	animating = true;
	repaint_all(false);
	if (animations.length) {
		animations.shift()();
	} else if (valid_clicks.size === 1) {
		animating = false;

		// check for automatic forced moves
		let autoclick = false;
		if (Config.auto_draw)
			if (valid_clicks.has(Pile.get("Deck")) && Pile.get("Deck").length)
				autoclick = true;
		if (Config.auto_build)
			if (state===STATE_BUILD_DRAW || state===STATE_BUILD_ROYAL || state===STATE_BUILD_CARD || state===STATE_BUILD_ENEMY)
				autoclick = true;

		if (autoclick)
			clicked( valid_clicks.values().next().value );
	}
}

</script>

</body></html>
